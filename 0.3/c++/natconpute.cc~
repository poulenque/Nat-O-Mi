#include <iostream>
#include "natconpute.h"
#include <muParser.h>
#include <boost/lexical_cast.hpp>

// Function string to double
double StrToDouble(std::string const& s)
{
	double value;
    try {
        value = boost::lexical_cast<double>(s);
    } catch (boost::bad_lexical_cast const& e){
		value = std::numeric_limits<double>::quiet_NaN();
    }
	return value;
}

//Main function
std::vector <size_t> calculinit(const std::vector<natInfo>& data_info, mu::Parser& p)
{
	std::string formula="";
	vector <size_t> ret;
	for(unsigned int i(0); i < data_info.size();++i)
	{
		if(!(data_info[i].formula.empty()))// if the formula field isnot empty
		{
			ret.push_back(i);				//remember the column with formula to apply
			formula += data_info[i].name+"="+data_info[i].formula + ",";	//write down the formula
		}
	}
	//p.SetExpr(formula.erase(formula.length() -1)); // set the formula expression for multiple formula evaluations
	p.SetExpr("I=Temps*sqrt(VolumeH),Faraday=U_error+I");
	return ret;
}

void natomi_core(const std::vector<natInfo>& data_info, std::vector<std::string>& line, const std::vector<size_t>& formula_col, mu::Parser& p, map<std::string,size_t> dataName_str2num)
{

  try
  {
	std::vector<double> vars;
	p.ClearVar();
	for(unsigned int i(0); i < line.size();i++)
	{	//TODO GLAA BIZARRE
		vars.push_back(StrToDouble(line[i]));
		if(vars[i] != std::numeric_limits<double>::quiet_NaN())
		{
			p.DefineVar(data_info[i].name, &vars[i]);
			std::cout << i << " " << data_info[i].name << " " << &vars[i] << " " << vars[i] << std::endl;
		}
	}
	p.Diff();
	int nNum;
  	double *v = p.Eval(nNum);
	std::cout << p.GetExpr() << std::endl;
  	for (int i=0; i<nNum; ++i)
  	{
    	std::cout << v[i] << "\n";
  	}

  }//catch(...){}
  catch (mu::Parser::exception_type &e){ 
	if(e.GetCode()==1)
		std::cout << e.GetMsg() << "\nUnrecognised variable from formula: "  << e.GetExpr()<< std::endl;
	}

  
}
